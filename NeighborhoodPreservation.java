/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (c) 2005-2007 Universidade de Sao Paulo, Sao Carlos/SP, Brazil.
 * All Rights Reserved.
 *
 * This file is part of Projection Explorer (PEx).
 *
 * How to cite this work:
 *  
@inproceedings{paulovich2007pex,
author = {Fernando V. Paulovich and Maria Cristina F. Oliveira and Rosane 
Minghim},
title = {The Projection Explorer: A Flexible Tool for Projection-based 
Multidimensional Visualization},
booktitle = {SIBGRAPI '07: Proceedings of the XX Brazilian Symposium on 
Computer Graphics and Image Processing (SIBGRAPI 2007)},
year = {2007},
isbn = {0-7695-2996-8},
pages = {27--34},
doi = {http://dx.doi.org/10.1109/SIBGRAPI.2007.39},
publisher = {IEEE Computer Society},
address = {Washington, DC, USA},
}
 *  
 * PEx is free software: you can redistribute it and/or modify it under 
 * the terms of the GNU General Public License as published by the Free 
 * Software Foundation, either version 3 of the License, or (at your option) 
 * any later version.
 *
 * PEx is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
 * for more details.
 *
 * This code was developed by members of Computer Graphics and Image
 * Processing Group (http://www.lcad.icmc.usp.br) at Instituto de Ciencias
 * Matematicas e de Computacao - ICMC - (http://www.icmc.usp.br) of 
 * Universidade de Sao Paulo, Sao Carlos/SP, Brazil. The initial developer 
 * of the original code is Fernando Vieira Paulovich <fpaulovich@gmail.com>.
 *
 * Contributor(s): Rosane Minghim <rminghim@icmc.usp.br>
 *
 * You should have received a copy of the GNU General Public License along 
 * with PEx. If not, see <http://www.gnu.org/licenses/>.
 *
 * ***** END LICENSE BLOCK ***** */

package dataanalysis;

import dataanalysis.ttest.TTestDialog;
import datamining.neighbors.KNN;
import datamining.neighbors.Pair;
import distance.DetailedDistanceMatrix;
import distance.DistanceMatrix;
import distance.dissimilarity.AbstractDissimilarity;
import distance.dissimilarity.Euclidean;
import graph.model.Connectivity;
import graph.model.Edge;
import graph.model.GraphInstance;
import graph.model.GraphModel;
import java.awt.*;
import java.awt.geom.Rectangle2D;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import matrix.AbstractMatrix;
import matrix.dense.DenseMatrix;
import matrix.dense.DenseVector;
import net.sf.epsgraphics.ColorMode;
import net.sf.epsgraphics.EpsGraphics;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.DefaultDrawingSupplier;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import projection.model.ProjectionInstance;
import projection.model.ProjectionModel;
import projection.model.Scalar;
import simpletree.model.SimpleTreeModel;
import simpletree.util.TreeDistanceCalculator;
import util.filter.EPSFilter;
import visualizationbasics.model.AbstractInstance;
import visualizationbasics.util.SaveDialog;

/**
 *
 * @author  Fernando Vieira Paulovich
 */
public class NeighborhoodPreservation extends javax.swing.JDialog {

    /** Creates new form NeighborhoodPreservation */
    private NeighborhoodPreservation(javax.swing.JDialog parent) {
        super(parent);
        initComponents();
        this.setModal(false);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonPanel = new javax.swing.JPanel();
        saveImageButton = new javax.swing.JButton();
        ttestButton = new javax.swing.JButton();
        closeButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Neighborhood Preservation");
        setModal(true);

        saveImageButton.setText("Save Image");
        saveImageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveImageButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(saveImageButton);

        ttestButton.setText("TTest");
        ttestButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ttestButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(ttestButton);

        closeButton.setText("Close");
        closeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(closeButton);

        getContentPane().add(buttonPanel, java.awt.BorderLayout.PAGE_END);

        pack();
    }// </editor-fold>//GEN-END:initComponents
    private void saveImageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveImageButtonActionPerformed
        int result = SaveDialog.showSaveDialog(new EPSFilter(),this,"","image.eps");

        if (result == JFileChooser.APPROVE_OPTION) {
            String filename = SaveDialog.getFilename();

            FileOutputStream out = null;

            try {
                // Save this document to example.eps
                out = new FileOutputStream(filename);

                // Create a new document with bounding box 0 <= x <= 100 and 0 <= y <= 100.
                EpsGraphics g = new EpsGraphics(filename, out, 0, 0,
                        panel.getWidth() + 1, panel.getHeight() + 1, ColorMode.COLOR_RGB);

                freechart.draw(g, new Rectangle2D.Double(0, 0, panel.getWidth() + 1,
                        panel.getHeight() + 1));

                // Flush and close the document (don't forget to do this!)
                g.flush();
                g.close();

            } catch (IOException ex) {
                Logger.getLogger(NeighborhoodPreservation.class.getName()).log(Level.SEVERE, null, ex);
                JOptionPane.showMessageDialog(this, ex.getMessage(),
                        "Problems saving the file", JOptionPane.ERROR_MESSAGE);
            } finally {
                if (out != null) {
                    try {
                        out.flush();
                        out.close();
                    } catch (IOException ex) {
                        Logger.getLogger(NeighborhoodPreservation.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }
        }
    }//GEN-LAST:event_saveImageButtonActionPerformed

    private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
        this.setVisible(false);
    }//GEN-LAST:event_closeButtonActionPerformed

    private void ttestButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ttestButtonActionPerformed
        TTestDialog.getInstance(this).display("Neighborhood Preservation t-test",values);
    }//GEN-LAST:event_ttestButtonActionPerformed

    public static NeighborhoodPreservation getInstance(javax.swing.JDialog parent) {
        return new NeighborhoodPreservation(parent);
    }

    public TreeMap<String,double[]> display(final DistanceMatrix dmatdata, final ArrayList<Serie> series,
                        ArrayList<DistanceMatrix> dmats, final int maxneigh, final boolean useVisEuclideanDistance,
                        final boolean useWeight, final boolean useEuclideanAsWeights, int distanceCalcType) {
        final MessageDialog md = MessageDialog.show(this, "Calculating neighborhood preservation...");

//        Thread t = new Thread() {
//
//            @Override
//            public void run() {
                try {
                    NeighborhoodPreservation.this.freechart = createChart(createAllSeries(dmatdata, series, dmats, maxneigh, useVisEuclideanDistance, useWeight, useEuclideanAsWeights,distanceCalcType));
                    if (NeighborhoodPreservation.this.freechart != null) {
                        //Uncomment and Modify this to specify a fixed range for y values.
//                        XYPlot plot = NeighborhoodPreservation.this.freechart.getXYPlot();
//                        NumberAxis axis = (NumberAxis)plot.getRangeAxis();
//                        axis.setRange(-0.1,0.7); //Modify these values.
//                        axis.setTickUnit(new NumberTickUnit(0.1));
                        //
                        NeighborhoodPreservation.this.panel = new ChartPanel(freechart);
                        NeighborhoodPreservation.this.getContentPane().add(panel, BorderLayout.CENTER);
                        NeighborhoodPreservation.this.setPreferredSize(new Dimension(650, 375));
                        NeighborhoodPreservation.this.setSize(new Dimension(650, 375));
                        NeighborhoodPreservation.this.setLocationRelativeTo(NeighborhoodPreservation.this.getParent());
                        md.close();
                        NeighborhoodPreservation.this.setVisible(true);
                        return values;
                    } else {
                        md.close();
                        return null;
                    }
                } catch (IOException ex) {
                    Logger.getLogger(NeighborhoodPreservation.class.getName()).log(Level.SEVERE, null, ex);
                    return null;
                }
//            }
//
//        };

        //t.start();
    }

    private JFreeChart createChart(XYDataset xydataset) {
        if (xydataset == null) return null;
        //JFreeChart chart = ChartFactory.createXYLineChart("Neighborhood Preservation", "Number Neighbors", "Precision", xydataset, PlotOrientation.VERTICAL, true, true, false);
        JFreeChart chart = ChartFactory.createXYLineChart("", "Number of Neighbors", "Precision", xydataset, PlotOrientation.VERTICAL, true, true, false);

        chart.setBackgroundPaint(Color.WHITE);
        
        XYPlot xyplot = (XYPlot) chart.getPlot();
        NumberAxis numberaxis = (NumberAxis) xyplot.getRangeAxis();
        numberaxis.setAutoRangeIncludesZero(false);

        xyplot.setDomainGridlinePaint(Color.BLACK);
        xyplot.setRangeGridlinePaint(Color.BLACK);

        xyplot.setOutlinePaint(Color.BLACK);
        xyplot.setOutlineStroke(new BasicStroke(1.0f));
        xyplot.setBackgroundPaint(Color.white);
        xyplot.setDomainCrosshairVisible(true);
        xyplot.setRangeCrosshairVisible(true);

        xyplot.setDrawingSupplier(new DefaultDrawingSupplier(
                new Paint[]{Color.RED, Color.BLUE, Color.GREEN, Color.MAGENTA,
                    Color.CYAN, Color.ORANGE, Color.BLACK, Color.DARK_GRAY, Color.GRAY,
                    Color.LIGHT_GRAY, Color.YELLOW
                }, DefaultDrawingSupplier.DEFAULT_OUTLINE_PAINT_SEQUENCE,
                DefaultDrawingSupplier.DEFAULT_STROKE_SEQUENCE,
                DefaultDrawingSupplier.DEFAULT_OUTLINE_STROKE_SEQUENCE,
                DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE));

        XYLineAndShapeRenderer xylineandshaperenderer = (XYLineAndShapeRenderer) xyplot.getRenderer();
        xylineandshaperenderer.setBaseShapesVisible(true);
        xylineandshaperenderer.setBaseShapesFilled(true);
        xylineandshaperenderer.setDrawOutlines(true);

        return chart;
    }

    private XYDataset createAllSeries(DistanceMatrix dmatdata, ArrayList<Serie> series,
                                      ArrayList<DistanceMatrix> dmats, int maxneigh, boolean useVisEuclideanDistance,
                                      boolean useWeight, boolean useEuclideanAsWeights,int distanceCalcType) throws IOException {
        XYSeriesCollection xyseriescollection = new XYSeriesCollection();

        //Creating series for models...
        for (int i = 0; i < series.size(); i++) {
            if (values == null) values = new TreeMap<String,double[]>();
            double[] serieValues = this.neighborhood(series.get(i).model,dmatdata,maxneigh,useVisEuclideanDistance,useWeight,useEuclideanAsWeights,distanceCalcType);
            //XYSeries xyseries = createSerie(series.get(i).name,serieValues);
            //xyseriescollection.addSeries(xyseries);
            if (values.containsKey(series.get(i).name)) {
                int idx = 0;
                String newName = series.get(i).name;
                do {
                    idx++;
                    newName += " "+idx;
                }while (values.containsKey(newName));
                values.put(newName,serieValues);
            }else
                values.put(series.get(i).name,serieValues);
        }
        //Creating series for matrices...
//        if (matrices != null) {
//            for (int i = 0; i < matrices.size(); i++) {
//                if (values == null) values = new HashMap<String,double[]>();
//                double[] serieValues = this.neighborhood(matrices.get(i),dmatdata,maxneigh,useVisEuclideanDistance,useWeight,useEuclideanAsWeights);
//                XYSeries xyseries = createSerie(matrices.get(i).toString(),serieValues);
//                xyseriescollection.addSeries(xyseries);
//                values.put(matrices.get(i).toString(),serieValues);
//            }
//        }
        //Creating series for dmats...
        if (dmats != null) {
            for (int i = 0; i < dmats.size(); i++) {
                if (values == null) values = new TreeMap<String,double[]>();
                double[] serieValues = this.neighborhood(dmats.get(i),dmatdata,maxneigh);
                String name = "";
                if (dmats.get(i) instanceof DetailedDistanceMatrix)
                    name = ((DetailedDistanceMatrix)dmats.get(i)).getName();
                else
                    name = dmats.get(i).toString();
                if (name.isEmpty())
                    name = "Distance Matrix "+i;
                //XYSeries xyseries = createSerie(name,serieValues);
                values.put(name,serieValues);
//                if (dmats.get(i) instanceof DetailedDistanceMatrix) {
//
//                } else {
//                    xyseries = createSerie(dmats.get(i).toString(),serieValues);
//                    values.put(dmats.get(i).toString(), serieValues);
//                }
                //xyseriescollection.addSeries(xyseries);
            }
        }
        
        for (int i=0;i<values.size();i++) {
            xyseriescollection.addSeries(createSerie((String)values.keySet().toArray()[i],(double[])values.values().toArray()[i]));
        }
        
        return xyseriescollection;
    }

    private XYSeries createSerie(String name, double[] values) {
        XYSeries xyseries = new XYSeries(name);

        for (int i = 0; i < values.length; i++) {
            xyseries.add(i + 1, values[i]);
        }

        return xyseries;
    }

    public static AbstractMatrix exportPoints(ArrayList<AbstractInstance> instances, Scalar scalar) {

        AbstractMatrix matrix = new DenseMatrix();

        if (scalar == null) {
            return null;
//            ArrayList<Scalar> scalars = model.getScalars();
//            if ((scalars != null)&&(!scalars.isEmpty())) scalar = scalars.get(0);
        }

        ArrayList<String> labels = new ArrayList<String>();

          for (int i = 0; i < instances.size(); i++) {
            float[] point = new float[2];
            point[0] = ((ProjectionInstance)instances.get(i)).getX();
            point[1] = ((ProjectionInstance)instances.get(i)).getY();

            float cdata = ((ProjectionInstance)instances.get(i)).getScalarValue(scalar);
            Integer id = ((ProjectionInstance)instances.get(i)).getId();
            labels.add(((ProjectionInstance)instances.get(i)).toString());

            matrix.addRow(new DenseVector(point, id, cdata));
        }

        matrix.setLabels(labels);

        ArrayList<String> attributes = new ArrayList<String>();
        attributes.add("x");
        attributes.add("y");

        matrix.setAttributes(attributes);

        return matrix;
    }

    public Connectivity createEuclideanWeightConnectivity(GraphModel model, Connectivity con) {

        AbstractMatrix points = exportPoints(model.getInstances(),model.addScalar("cdata"));

        ArrayList<Edge> connEdges = con.getEdges();
        ArrayList<Integer> ids = points.getIds();
        ArrayList<Edge> euclideanDistEdges = new ArrayList<Edge>();

        if (connEdges == null) return null;
        if (ids == null) return null;

        for (int i=0;i<connEdges.size();i++) {
            int source = connEdges.get(i).getSource();
            int target = connEdges.get(i).getTarget();
            if (ids.indexOf(source) != -1 && ids.indexOf(target) != -1) {
                float distance = (new Euclidean()).calculate(points.getRow(ids.indexOf(source)),points.getRow(ids.indexOf(target)));
                euclideanDistEdges.add(new Edge(source,target,distance));
            }
        }

        Connectivity conn = new Connectivity("Plane Euclidian",euclideanDistEdges);
        return conn;
    }

    public DistanceMatrix createDistanceMatrixByFloydWarshall(GraphModel model, boolean useWeights,Connectivity euclideanDistAsWeightsCon) {

        DistanceMatrix dm = new DistanceMatrix();

        float[][] dmat = new float[model.getInstances().size()][model.getInstances().size()];
        for (int i=0;i<dmat.length;i++)
            for (int j=0;j<dmat[i].length;j++)
                if (i == j) dmat[i][j] = 0;
                else dmat[i][j] = Float.MAX_VALUE;

        ArrayList<Edge> edges = null;

        if (euclideanDistAsWeightsCon != null) {
            edges = euclideanDistAsWeightsCon.getEdges();
        }else {
            if (model.getSelectedConnectivity() != null)
                edges = model.getSelectedConnectivity().getEdges();
            else if ((model.getConnectivities() != null)&&(model.getConnectivities().size() > 1))
                    edges = model.getConnectivities().get(1).getEdges();
        }

        if (edges == null) return null;

//        String[] sdmat = new String[model.getInstances().size()];
//        for (int i=0;i<sdmat.length;i++) sdmat[i] = "";
        
        for (int k=0;k<edges.size();k++) {
            Edge ed = edges.get(k);
            int x = model.getInstances().indexOf(getInstanceById(model,ed.getSource()));
            int y = model.getInstances().indexOf(getInstanceById(model,ed.getTarget()));
            if (useWeights) dmat[x][y] = dmat[y][x] = ed.getWeight();
            else dmat[x][y] = dmat[y][x] = 1.0f;
//            String text = "";
//            if (getInstanceById(model,ed.getSource()).isValid()) text = "N";
//            else text = "V";
//            sdmat[x] = text;
//            if (getInstanceById(model,ed.getTarget()).isValid()) text = "N";
//            else text = "V";
//            sdmat[y] = text;
        }
        
//        for (int k=0; k<sdmat.length; k++)
//            System.out.print(sdmat[k]+" ");
        

        //Calculating the shortest path, in the tree, among all nodes (including virtual nodes)
        //Floyd Warshall algorithm.
        int n = dmat.length;
        for (int k=0; k<n; k++)
            for (int i=0; i<n; i++)
                for (int j=0; j<n; j++) {
                    float dd = dmat[i][k] + dmat[k][j];
                    if (dmat[i][j] > dd) dmat[i][j] = dd;
                }
        
//        for (int k=0; k<n; k++) {
//            for (int i=0; i<n; i++) {
//                float aji = dmat[k][i];
//                for (int j=0; j<i; j++) {
//                    dmat[i][j] = Math.min(dmat[i][j],aji+dmat[k][j]);
//                    dmat[j][i] = dmat[i][j];
//                }
//            }
//        }

        int k = -1;
        ArrayList<ArrayList<Float>> ndmat = new ArrayList<ArrayList<Float>>();
        for (int i=0;i<dmat.length;i++) {
            if (model instanceof SimpleTreeModel) {
                if (((GraphInstance)model.getInstances().get(i)).isValid()) {
                    k++;
                    ndmat.add(new ArrayList<Float>());
                    for (int j=0;j<dmat[i].length;j++) {
                        if (((GraphInstance)model.getInstances().get(j)).isValid()) {
                            ndmat.get(k).add(dmat[i][j]);
                        }
                    }
                }
            }else {
                if (!model.getInstances().get(i).toString().isEmpty()) {
                //if (!((GraphInstance)model.getInstances().get(i)).isValid()) {
                    k++;
                    ndmat.add(new ArrayList<Float>());
                    for (int j=0;j<dmat[i].length;j++) {
                        if (!model.getInstances().get(j).toString().isEmpty()) {
                        //if (!((GraphInstance)model.getInstances().get(j)).isValid()) {
                            ndmat.get(k).add(dmat[i][j]);
                        }
                    }
                }
            }
        }

        //Create and fill the distance distmatrix
        dm.setElementCount(ndmat.size());

        float maxDistance = Float.NEGATIVE_INFINITY;
        float minDistance = Float.POSITIVE_INFINITY;

        float[][] distmat = new float[ndmat.size() - 1][];
        for (int i=0; i<ndmat.size()-1; i++) {
            distmat[i] = new float[i + 1];
            for (int j=0;j<distmat[i].length; j++) {
                float distance = ndmat.get(i+1).get(j);
                if (distance < minDistance) minDistance = distance;
                if (distance > maxDistance) maxDistance = distance;
                if ((i+1)!=j) {
                    if ((i+1) < j) distmat[j - 1][(i+1)] = distance;
                    else distmat[(i+1) - 1][j] = distance;
                }
            }
        }
        dm.setMinDistance(minDistance);
        dm.setMaxDistance(maxDistance);
        dm.setDistmatrix(distmat);
        
//        try {
//            dm.save("D:\\DistUsingWalsh.dmat");
//        } catch (IOException ex) {
//            Logger.getLogger(NeighborhoodPreservation.class.getName()).log(Level.SEVERE, null, ex);
//        }
        
        return dm;

    }

    public DistanceMatrix createDistanceMatrixByHeight(DistanceMatrix dataDmat, GraphModel model, boolean useWeights, Connectivity euclideanDistAsWeightsCon) {

        DistanceMatrix dm = new DistanceMatrix();

        ArrayList<Edge> edges = null;

        if (euclideanDistAsWeightsCon != null) {
            edges = euclideanDistAsWeightsCon.getEdges();
        }else {
            if (model.getSelectedConnectivity() != null)
                edges = model.getSelectedConnectivity().getEdges();
            else if ((model.getConnectivities() != null)&&(model.getConnectivities().size() > 1))
                    edges = model.getConnectivities().get(1).getEdges();
        }

        if (edges == null) return null;

        //Create and fill the distance distmatrix
        int numInstances = getValidInstances(model).size();
        dm.setElementCount(numInstances);

        float maxDistance = Float.NEGATIVE_INFINITY;
        float minDistance = Float.POSITIVE_INFINITY;

        System.out.println("Creating distance matrix from tree...");
        TreeDistanceCalculator t = new TreeDistanceCalculator();
        float[][] distmat = new float[numInstances - 1][];
        for (int i=0; i<numInstances-1; i++) {
            if (i % ((int)(numInstances*0.1)) == 0) System.out.println("-- Processing instance "+i);
            distmat[i] = new float[i + 1];
            for (int j=0;j<distmat[i].length; j++) {
                float distance = t.getDistance(edges,dataDmat.getIds().get(j),dataDmat.getIds().get(i+1),useWeights);
                if (distance < minDistance) minDistance = distance;
                if (distance > maxDistance) maxDistance = distance;
                distmat[i][j] = distance;
                //if ((i+1)!=j) {
                //    if ((i+1) < j) distmat[j - 1][(i+1)] = distance;
                //    else distmat[(i+1) - 1][j] = distance;
                //}
            }
        }
        dm.setMinDistance(minDistance);
        dm.setMaxDistance(maxDistance);
        dm.setDistmatrix(distmat);
//        try {
//            dm.save("D:\\DistUsingHeights.dmat");
//        } catch (IOException ex) {
//            Logger.getLogger(NeighborhoodPreservation.class.getName()).log(Level.SEVERE, null, ex);
//        }

        System.out.println("Distance matrix from tree created.");
        return dm;

    }
    
    private double[] neighborhood(ProjectionModel model, DistanceMatrix dataDmat, int maxneigh,
                                  boolean useVisEuclideanDistance, boolean useWeight, boolean useEuclideanAsWeights, int distanceCalcType) throws IOException {

        double[] valuesRet = new double[maxneigh];
        if (model == null) return valuesRet;

        Scalar scdata = model.addScalar("cdata");
                
        DistanceMatrix projectionDmat = null;
        AbstractMatrix validPoints = null;

        if (model instanceof GraphModel) {//Hierarquical Projection, uses paths to determine distances...
            //validPoints = exportPoints(((LabeledGraphModel)model).getValidInstances(),scdata);
            validPoints = exportPoints(getValidInstances((GraphModel)model),scdata);
            if (useVisEuclideanDistance)
                projectionDmat = new DistanceMatrix(validPoints, new Euclidean());
            else {
                if (useEuclideanAsWeights) {
                    Connectivity gCon = null;
                    if (((GraphModel)model).getSelectedConnectivity() != null)
                        gCon = ((GraphModel)model).getSelectedConnectivity();
                    else if ((((GraphModel)model).getConnectivities() != null)&&(((GraphModel)model).getConnectivities().size() > 1))
                            gCon = ((GraphModel)model).getConnectivities().get(1);
                    if (gCon == null) throw new IOException("Error: Graph connectivity not found.");
                    Connectivity euclideanWeightsConn = createEuclideanWeightConnectivity((GraphModel)model,gCon);
                    //projectionDmat = createDistanceMatrix((LabeledGraphModel)model,useWeight,euclideanWeightsConn);
                    switch (distanceCalcType) {
                        case 0:
                            projectionDmat = createDistanceMatrixByFloydWarshall((GraphModel)model,useWeight,euclideanWeightsConn);
                            break;
                        case 1:
                            projectionDmat = createDistanceMatrixByHeight(dataDmat,(GraphModel)model,useWeight,euclideanWeightsConn);
                            break;
                    }
                } else {
                    //projectionDmat = createDistanceMatrix((LabeledGraphModel)model,useWeight,null);
                    //projectionDmat = createDistanceMatrix(dataDmat,(GraphModel)model,useWeight,null);
                    switch (distanceCalcType) {
                        case 0:
                            projectionDmat = createDistanceMatrixByFloydWarshall((GraphModel)model,useWeight,null);
                            break;
                        case 1:
                            projectionDmat = createDistanceMatrixByHeight(dataDmat,(GraphModel)model,useWeight,null);
                            break;
                    }
                }
                
                ArrayList<String> labels = validPoints.getLabels();
                ArrayList<Integer> ids = validPoints.getIds();

                float[] c = validPoints.getClassData();
//                ArrayList<Float> cdatas = new ArrayList<Float>();

//                int k=0;
//                //excluding virtual nodes...
//                for (int i=0;i<labels.size();i++) {
//                    if (labels.get(i).isEmpty()) {
//                        labels.remove(i);
//                        ids.remove(i);
//                        i--;
//                    }else cdatas.add(c[k]);
//                    k++;
//                }
//                float[] c2 = new float[cdatas.size()];
//                for (int i=0;i<cdatas.size();i++) c2[i] = cdatas.get(i);
                projectionDmat.setLabels(labels);
                projectionDmat.setIds(ids);
                projectionDmat.setClassData(c);
            }
        }else {
            validPoints = exportPoints(model.getInstances(),scdata);
            projectionDmat = new DistanceMatrix(validPoints, new Euclidean());
        }

//        if (dataDmat.getElementCount() != projectionDmat.getElementCount()) {
//            //throw new IOException("Data set different from projection.");
//            System.out.println("Data set different from projection!");
//            return null;
//        }

        KNN knnproj = new KNN(maxneigh);
        Pair[][] nproj = knnproj.execute(projectionDmat);

        KNN knndata = new KNN(maxneigh);
        Pair[][] ndata = knndata.execute(dataDmat);
//boolean f = false;
        System.out.println("Calculating neighbors...");
        for (int n = 0; n < maxneigh; n++) {
            float percentage = 0.0f;
            System.out.println("- Calculating neighbor "+n);
            for (int i = 0; i < projectionDmat.getElementCount(); i++) {
                float total = 0.0f;
                if (i % ((int)(projectionDmat.getElementCount()*0.1)) == 0) System.out.println("-- Calculating neighborhood pres for instance "+i);
//                for (int j = 0; j < n + 1; j++) {
//                    if (this.contains(nproj[i], n + 1, ndata[i][j].index)) {
//                    //if (this.containsUsingID(ndata, n + 1, nproj[i][j].index,dataDmat,projectionDmat)) {
//                        total++;
//                    }
//                }

                
                int idProjection = projectionDmat.getIds().get(i);
                //Buscando a linha, na matrix de neighbors original, correspondente aos vizinhos mais proximos da instancia com idProjection...
                int id = dataDmat.getIds().indexOf(idProjection);
                if (id != -1) {
//                    if (!f) {
//                        for (int k=0;k<ndata[id].length;k++)
//                            System.out.print(dataDmat.getLabels().get(ndata[id][k].index)+" ");
//                        System.out.println("-------------");
//                        for (int k=0;k<nproj[i].length;k++)
//                            System.out.print(projectionDmat.getLabels().get(nproj[i][k].index)+" ");
//                        f = true;
//                    }
                    for (int j = 0; j < n + 1; j++) {
                        //if (this.contains(nproj[i], n + 1, ndata[i][j].index)) {
                        if (this.containsUsingID(ndata[id], n + 1, nproj[i][j].index,dataDmat,projectionDmat)) {
                            total++;
                        }
                    }
                }
                percentage += total / (n + 1);
            }
            //System.out.println(n+" : "+percentage);

            valuesRet[n] = new Double(percentage / projectionDmat.getElementCount());
        }
        
        System.out.println("Neighborhood Preservation:");
        StringBuilder resp = new StringBuilder();
        if (valuesRet != null && valuesRet.length > 0) {
            resp.append("[ ");
            for (int ii=0;ii<valuesRet.length;ii++)
                resp.append(valuesRet[ii]+" ");
            resp.append("]");
        }
        System.out.println(resp);
        return valuesRet;
    }

    private double[] neighborhood(AbstractMatrix matrix, AbstractDissimilarity diss, DistanceMatrix dataDmat, int maxneigh) throws IOException {

        double[] valuesRet = new double[maxneigh];
        DistanceMatrix dmat = new DistanceMatrix(matrix, diss);
        if (dmat != null)
            valuesRet = neighborhood(dmat,dataDmat,maxneigh);
        return valuesRet;
        
    }

    private double[] neighborhood(DistanceMatrix dmat, DistanceMatrix dataDmat, int maxneigh) throws IOException {

        double[] valuesRet = new double[maxneigh];
        if (dmat == null) return valuesRet;

        KNN knnproj = new KNN(maxneigh);
        Pair[][] nproj = knnproj.execute(dmat);

        KNN knndata = new KNN(maxneigh);
        Pair[][] ndata = knndata.execute(dataDmat);
        for (int n = 0; n < maxneigh; n++) {
            float percentage = 0.0f;
            for (int i = 0; i < dmat.getElementCount(); i++) {
                float total = 0.0f;
                int idProjection = dmat.getIds().get(i);
                //Buscando a linha, na matrix de neighbors original, correspondente aos vizinhos mais proximos da instancia com idProjection...
                int id = dataDmat.getIds().indexOf(idProjection);
                if (id != -1)
                    for (int j = 0; j < n + 1; j++)
                        if (this.containsUsingID(ndata[id], n + 1, nproj[i][j].index,dataDmat,dmat))
                            total++;
                percentage += total / (n + 1);
            }
            valuesRet[n] = new Double(percentage / dmat.getElementCount());
        }
        return valuesRet;
    }

    private boolean contains(Pair[] neighbors, int length, int index) {
        for (int i = 0; i < length; i++) {
            if (neighbors[i].index == index) {
                return true;
            }
        }
        return false;
    }

    private boolean containsUsingID(Pair[] neighborsData, int length, int indexProjection, DistanceMatrix dataDmat, DistanceMatrix projectionDmat) {
        int idProjection = projectionDmat.getIds().get(indexProjection);
        //Buscando a linha, na matrix de neighbors original, correspondente aos vizinhos mais proximos da instancia com idProjection...
        int id = dataDmat.getIds().indexOf(idProjection);
        if (id != -1) {
            for (int i = 0; i < length; i++) {
                int idData = dataDmat.getIds().get(neighborsData[i].index);
                //System.out.println(dataDmat.getLabels().get(neighborsData[i].index) + " : " + projectionDmat.getLabels().get(indexProjection));
                if (idData == idProjection)
                    return true;
            }
            return false;
        }else return false;

    }

    //The next two methods are here because the GraphModel does not have them, but two of its subclasses, SIMPLETREEMODEL and LABELEDGRAPHMODEL have. The
    //ideal is put it on the GraphModel, it is not done because the project is on the trunk and I did not want to modify it.
    private GraphInstance getInstanceById(GraphModel model, int id) {
        for (int i=0;i<model.getInstances().size();i++) {
            if (model.getInstances().get(i).getId() == id) {
                return (GraphInstance)model.getInstances().get(i);
            }
        }
        return null;
    }
    
    private ArrayList<AbstractInstance> getValidInstances(GraphModel model) {
        ArrayList selinsts = model.getInstances();
        ArrayList<AbstractInstance> valids = new ArrayList<AbstractInstance>();
        if (selinsts != null) {
            for (int i=0;i<selinsts.size();i++) {
                if (((GraphInstance)(selinsts.get(i))).isValid())
                    valids.add((AbstractInstance) selinsts.get(i));
            }
        }
        return valids;
    }
    
    private JFreeChart freechart;
    private JPanel panel;
    private TreeMap<String,double[]> values;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel buttonPanel;
    private javax.swing.JButton closeButton;
    private javax.swing.JButton saveImageButton;
    private javax.swing.JButton ttestButton;
    // End of variables declaration//GEN-END:variables
}
